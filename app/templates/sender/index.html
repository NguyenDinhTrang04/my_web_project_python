{% extends 'base.html' %}
{% block content %}
<div class="container">
    <div class="header">
        <h1>üîê H·ªá Th·ªëng G·ª≠i B√°o C√°o T√†i Ch√≠nh An To√†n - <span class="text-primary">Ng∆∞·ªùi G·ª≠i</span></h1>
        <p>M√£ h√≥a AES-GCM + RSA 1024-bit + SHA-512 + N√©n zlib</p>
    </div>
    <div class="content">
        <div class="security-info">
            <h3>üõ°Ô∏è ƒê·∫∑c ƒêi·ªÉm B·∫£o M·∫≠t</h3>
            <ul class="security-list">
                <li>M√£ h√≥a d·ªØ li·ªáu: AES-GCM 256-bit</li>
                <li>Trao kh√≥a & k√Ω s·ªë: RSA 1024-bit (PKCS#1 v1.5)</li>
                <li>Ki·ªÉm tra to√†n v·∫πn: SHA-512</li>
                <li>N√©n d·ªØ li·ªáu: zlib ƒë·ªÉ gi·∫£m k√≠ch th∆∞·ªõc</li>
                <li>Handshake an to√†n v·ªõi x√°c th·ª±c hai chi·ªÅu</li>
            </ul>
        </div>
        <div class="section mb-4">
            <h2>ü§ù Handshake b·∫£o m·∫≠t</h2>
            <div class="mb-2">
                <label for="receiver_username" class="form-label fw-bold">T√™n ng∆∞·ªùi nh·∫≠n</label>
                <input type="text" class="form-control" id="receiver_username" name="receiver_username" placeholder="Nh·∫≠p username ng∆∞·ªùi nh·∫≠n" required>
                <div class="mt-2" id="receiver-status"></div>
            </div>
            <button id="start-handshake" class="btn btn-warning mb-2" disabled><i class="bi bi-link-45deg"></i> B·∫Øt ƒë·∫ßu handshake</button>
            <div id="handshake-status" class="alert alert-secondary" style="display:none;"></div>
        </div>
        <div class="section">
            <h2>üìÅ G·ª≠i File T√†i Ch√≠nh</h2>
            <div class="section mb-4">
                <h2>üîÑ Ti·∫øn tr√¨nh g·ª≠i file b·∫£o m·∫≠t</h2>
                <div class="progress" style="height: 30px;">
                    <div id="progress-bar-send" class="progress-bar progress-bar-striped progress-bar-animated bg-info" role="progressbar" style="width: 0%">Ch·ªù thao t√°c...</div>
                </div>
                <ul class="list-group mt-2" id="step-status-list-send">
                    <li class="list-group-item" id="step-handshake">1. Handshake <span class="badge bg-secondary">Ch·ªù</span></li>
                    <li class="list-group-item" id="step-sign">2. K√Ω s·ªë metadata <span class="badge bg-secondary">Ch·ªù</span></li>
                    <li class="list-group-item" id="step-compress">3. N√©n file <span class="badge bg-secondary">Ch·ªù</span></li>
                    <li class="list-group-item" id="step-encrypt">4. M√£ h√≥a file <span class="badge bg-secondary">Ch·ªù</span></li>
                    <li class="list-group-item" id="step-hash">5. T√≠nh hash <span class="badge bg-secondary">Ch·ªù</span></li>
                    <li class="list-group-item" id="step-send">6. G·ª≠i file <span class="badge bg-secondary">Ch·ªù</span></li>
                </ul>
            </div>
            <form id="send-file-form" enctype="multipart/form-data">
                <div class="mb-3">
                    <label for="file" class="form-label fw-bold">Ch·ªçn file ƒë·ªÉ g·ª≠i</label>
                    <input class="form-control" type="file" id="file" name="file" required>
                </div>
                <div class="mb-3">
                    <label for="private_key" class="form-label fw-bold">Private Key (PEM)</label>
                    <div class="input-group">
                        <textarea class="form-control" id="private_key" name="private_key" rows="4" placeholder="D√°n private key PEM c·ªßa b·∫°n t·∫°i ƒë√¢y" required></textarea>
                        <button class="btn btn-outline-secondary" type="button" id="fill-private-key">T·ª± ƒëi·ªÅn kh√≥a</button>
                    </div>
                </div>
                <div class="mb-3">
                    <label for="expiration" class="form-label fw-bold">Th·ªùi gian h·∫øt h·∫°n (ph√∫t, tu·ª≥ ch·ªçn)</label>
                    <input class="form-control" type="number" id="expiration" name="expiration" min="1" max="1440" placeholder="V√≠ d·ª•: 10 (m·∫∑c ƒë·ªãnh kh√¥ng gi·ªõi h·∫°n)">
                </div>
                <div class="d-grid gap-2">
                    <button type="submit" class="btn btn-primary btn-lg"><i class="bi bi-upload"></i> G·ª≠i File</button>
                </div>
            </form>
            <div id="send-file-result" class="mt-3"></div>
            <div id="send-file-debug-log" class="alert alert-secondary mt-3" style="display:none;"></div>
        </div>
        <div class="section mb-4">
            <h2>üë§ Th√¥ng tin t√†i kho·∫£n</h2>
            <div class="card mb-3">
                <div class="card-body">
                    <p><b>T√™n ƒëƒÉng nh·∫≠p:</b> {{ user_info.username }}</p>
                    <p><b>Public Key:</b><br><textarea class="form-control" rows="3" readonly>{{ user_info.public_key }}</textarea></p>
                    <p><b>Private Key (tr√¨nh duy·ªát l∆∞u):</b><br>
                        <textarea class="form-control" id="show_private_key" rows="3" readonly></textarea>
                        <button class="btn btn-outline-secondary mt-2" type="button" onclick="showPrivateKey()">Hi·ªán Private Key</button>
                    </p>
                </div>
            </div>
        </div>
        <div class="section mb-4">
            <h2>üîë Trao ƒë·ªïi Session Key</h2>
            <div class="mb-3">
                <label for="receiver_public_key" class="form-label fw-bold">Public Key c·ªßa ng∆∞·ªùi nh·∫≠n (b·∫Øt bu·ªôc nh·∫≠p/d√°n tr∆∞·ªõc khi g·ª≠i session key)</label>
                <textarea class="form-control" id="receiver_public_key" name="receiver_public_key" rows="3" placeholder="Nh·∫≠p ho·∫∑c d√°n public key c·ªßa ng∆∞·ªùi nh·∫≠n t·∫°i ƒë√¢y" required></textarea>
                <button class="btn btn-outline-info mt-2" type="button" id="fetch-receiver-public-key">L·∫•y Public Key t·ª´ h·ªá th·ªëng</button>
            </div>
            <button id="gen-session-key" class="btn btn-info mb-2" disabled>T·∫°o & g·ª≠i Session Key</button>
            <div id="session-key-status" class="alert alert-secondary" style="display:none;"></div>
            <div id="session-key-display" class="alert alert-info mt-3" style="display:none;"></div>
        </div>
        <div class="section mb-4">
            <h2>üóÇÔ∏è L·ªãch s·ª≠ g·ª≠i file</h2>
            <button class="btn btn-danger mb-2" id="clear-send-history"><i class="bi bi-trash"></i> X√≥a l·ªãch s·ª≠ g·ª≠i file</button>
            <div id="history-send-list">
                <table class="table table-bordered table-hover">
                    <thead class="table-light">
                        <tr>
                            <th>T√™n file</th>
                            <th>Ng∆∞·ªùi nh·∫≠n</th>
                            <th>Th·ªùi gian</th>
                            <th>Tr·∫°ng th√°i</th>
                        </tr>
                    </thead>
                    <tbody id="history-send-tbody">
                        <!-- L·ªãch s·ª≠ s·∫Ω ƒë∆∞·ª£c render ·ªü ƒë√¢y -->
                    </tbody>
                </table>
            </div>
        </div>
        <div class="section mb-4">
            <h2>üë§ ƒêƒÉng nh·∫≠p t√†i kho·∫£n g·ª≠i (t√°ch bi·ªát tr√¨nh duy·ªát)</h2>
            <div id="sender-login-section">
                <input type="text" class="form-control mb-2" id="sender-username-input" placeholder="Nh·∫≠p username ng∆∞·ªùi g·ª≠i" />
                <button class="btn btn-primary" id="save-sender-username">L∆∞u username</button>
            </div>
            <div id="sender-username-display" style="display:none;">
                <b>Username g·ª≠i:</b> <span id="current-sender-username"></span>
                <button class="btn btn-link btn-sm" id="change-sender-username">ƒê·ªïi</button>
            </div>
        </div>
    </div>
</div>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
<script>
const currentUsername = "{{ current_username }}";
let socket = io();
// ƒêƒÉng k√Ω username v·ªõi server khi k·∫øt n·ªëi socket
socket.on('connect', function() {
    const username = getSenderUsername();
    if (username) {
        emitRegisterUsername();
        console.log('[Socket] K·∫øt n·ªëi l·∫°i, t·ª± ƒë·ªông ƒëƒÉng k√Ω username:', username);
    } else {
        console.warn('[Socket] K·∫øt n·ªëi nh∆∞ng ch∆∞a nh·∫≠p username!');
    }
});
socket.on('reconnect', function() {
    const username = getSenderUsername();
    if (username) {
        emitRegisterUsername();
        console.log('[Socket] Reconnect, t·ª± ƒë·ªông ƒëƒÉng k√Ω l·∫°i username:', username);
    } else {
        console.warn('[Socket] Reconnect nh∆∞ng ch∆∞a nh·∫≠p username!');
    }
});

// --- Khai b√°o bi·∫øn to√†n c·ª•c, ch·ªâ 1 l·∫ßn ---
const handshakeBtn = document.getElementById('start-handshake');
const handshakeStatus = document.getElementById('handshake-status');
const sendFileForm = document.getElementById('send-file-form');
const fillKeyBtn = document.getElementById('fill-private-key');
const sessionKeyStatus = document.getElementById('session-key-status');
const genSessionKeyBtn = document.getElementById('gen-session-key');

let lastSessionKey = null;
let lastEncryptedSessionKey = null;
let lastReceiver = null;

// --- Progress/stepper c·∫≠p nh·∫≠t tr·∫°ng th√°i ---
function updateStepStatusSend(step, status, message) {
    const stepMap = {
        handshake: 0,
        sign: 1,
        compress: 2,
        encrypt: 3,
        hash: 4,
        send: 5
    };
    const bar = document.getElementById('progress-bar-send');
    const list = document.getElementById('step-status-list-send').children;
    const percent = [0, 16, 32, 48, 64, 80, 100];
    const idx = stepMap[step];
    for (let i = 0; i < list.length; i++) {
        const badge = list[i].querySelector('.badge');
        badge.classList.remove('fade-in');
        if (i < idx) {
            badge.className = 'badge bg-success fade-in';
            badge.innerHTML = '<i class="bi bi-check-circle"></i> Ho√†n th√†nh';
        } else if (i === idx) {
            if (status === 'error') {
                badge.className = 'badge bg-danger fade-in';
                badge.innerHTML = '<i class="bi bi-x-circle"></i> L·ªói';
            } else {
                badge.className = 'badge bg-warning text-dark fade-in';
                badge.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status"></span> ƒêang x·ª≠ l√Ω';
            }
        } else {
            badge.className = 'badge bg-secondary';
            badge.textContent = 'Ch·ªù';
        }
    }
    bar.style.width = percent[idx] + '%';
    bar.innerHTML = message ? `<span class="fade-in">${message}</span>` : list[idx].textContent;
    if (status === 'error') {
        bar.className = 'progress-bar bg-danger fade-in';
    } else if (idx === 6) {
        bar.className = 'progress-bar bg-success fade-in';
    } else {
        bar.className = 'progress-bar progress-bar-striped progress-bar-animated bg-info fade-in';
    }
}

// --- Handshake ---
// ƒê·∫£m b·∫£o ch·ªâ khai b√°o 1 l·∫ßn ·ªü ƒë·∫ßu file/script
if (typeof handshakeTimeout === 'undefined') {
    var handshakeTimeout = null;
}
if (typeof handshakeInProgress === 'undefined') {
    var handshakeInProgress = false;
}


// ƒê·∫£m b·∫£o handshake ch·ªâ g·ª≠i khi socket ƒë√£ connect v√† username ƒë√£ ƒëƒÉng k√Ω
handshakeBtn.onclick = function() {
    console.log('[DEBUG] handshakeBtn clicked');
    if (handshakeBtn.disabled) {
        console.warn('[DEBUG] handshakeBtn is disabled');
        return;
    }
    const currentUsername = getSenderUsername();
    console.log('[DEBUG] currentUsername:', currentUsername);
    if (!currentUsername) {
        handshakeStatus.style.display = 'block';
        showAlert(handshakeStatus, 'danger', 'B·∫°n ch∆∞a nh·∫≠p ho·∫∑c l∆∞u username ng∆∞·ªùi g·ª≠i!');
        console.warn('[Handshake] Kh√¥ng c√≥ username ng∆∞·ªùi g·ª≠i!');
        return;
    }
    if (!socket) {
        console.error('[DEBUG] socket is undefined');
        showAlert(handshakeStatus, 'danger', 'Socket ch∆∞a kh·ªüi t·∫°o!');
        return;
    }
    if (!socket.connected) {
        showAlert(handshakeStatus, 'danger', 'K·∫øt n·ªëi t·ªõi server b·ªã gi√°n ƒëo·∫°n. Vui l√≤ng th·ª≠ l·∫°i!');
        console.warn('[Handshake] Socket ch∆∞a k·∫øt n·ªëi!');
        return;
    }
    const receiver = getReceiverInputUsername();
    console.log('[DEBUG] receiver:', receiver);
    if (!receiver) {
        handshakeStatus.style.display = 'block';
        showAlert(handshakeStatus, 'danger', 'Vui l√≤ng nh·∫≠p t√™n ng∆∞·ªùi nh·∫≠n!');
        return;
    }
    handshakeStatus.style.display = 'block';
    showAlert(handshakeStatus, 'info', 'ƒêang g·ª≠i b·∫Øt tay...');
    console.log('[Handshake] G·ª≠i handshake_hello t·ªõi', receiver, 't·ª´', currentUsername);
    socket.emit('handshake_hello', {
        sender: currentUsername,
        receiver: receiver,
        message: 'Hello'
    });
    handshakeInProgress = true;
    if (handshakeTimeout) clearTimeout(handshakeTimeout);
    handshakeTimeout = setTimeout(() => {
        if (handshakeInProgress) {
            handshakeStatus.style.display = 'block';
            showAlert(handshakeStatus, 'danger', 'Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi handshake t·ª´ ng∆∞·ªùi nh·∫≠n. Vui l√≤ng ki·ªÉm tra l·∫°i tr·∫°ng th√°i online ho·∫∑c th·ª≠ l·∫°i!');
            updateStepStatusSend('handshake', 'error', 'Handshake th·∫•t b·∫°i!');
            handshakeInProgress = false;
        }
    }, 5000);
};
// Log khi nh·∫≠n handshake_ready
socket.on('handshake_ready', function(data) {
    console.log('[Handshake] Nh·∫≠n handshake_ready:', data);
    handshakeStatus.style.display = 'block';
    // Ph√¢n bi·ªát ph·∫£n h·ªìi handshake ch·ªß ƒë·ªông hay reply t·ª´ receiver
    let infoMsg = data && data.sender && data.receiver
        ? `Ph·∫£n h·ªìi b·∫Øt tay t·ª´ <b>${data.sender}</b> t·ªõi <b>${data.receiver}</b>: ${data.message}`
        : data.message;
    showAlert(handshakeStatus, 'success', infoMsg);
    updateStepStatusSend('handshake', 'done', 'Handshake th√†nh c√¥ng!');
    handshakeInProgress = false;
    if (handshakeTimeout) clearTimeout(handshakeTimeout);
});

// --- H√†m h·ªó tr·ª£ crypto ---
async function importPrivateKey(pem) {
    const pemHeader = "-----BEGIN PRIVATE KEY-----";
    const pemFooter = "-----END PRIVATE KEY-----";
    let pemContents = pem.replace(pemHeader, '').replace(pemFooter, '').replace(/\s/g, '');
    const binaryDer = Uint8Array.from(atob(pemContents), c => c.charCodeAt(0));
    return await window.crypto.subtle.importKey(
        'pkcs8',
        binaryDer.buffer,
        { name: 'RSASSA-PKCS1-v1_5', hash: 'SHA-512' },
        false,
        ['sign']
    );
}
async function importPublicKey(pem) {
    const pemHeader = "-----BEGIN PUBLIC KEY-----";
    const pemFooter = "-----END PUBLIC KEY-----";
    let pemContents = pem.replace(pemHeader, '').replace(pemFooter, '').replace(/\s/g, '');
    const binaryDer = Uint8Array.from(atob(pemContents), c => c.charCodeAt(0));
    return await window.crypto.subtle.importKey(
        'spki',
        binaryDer.buffer,
        { name: 'RSA-OAEP', hash: 'SHA-256' },
        false,
        ['encrypt']
    );
}
async function generateSessionKey() {
    return await window.crypto.subtle.generateKey(
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
    );
}
async function exportSessionKey(key) {
    return await window.crypto.subtle.exportKey('raw', key);
}
async function encryptSessionKey(sessionKeyBuffer, receiverPublicKeyPem) {
    const publicKey = await importPublicKey(receiverPublicKeyPem);
    return await window.crypto.subtle.encrypt(
        { name: 'RSA-OAEP' },
        publicKey,
        sessionKeyBuffer
    );
}
function createMetadata(file) {
    return {
        filename: file.name,
        timestamp: new Date().toISOString(),
        filetype: file.type
    };
}
async function signMetadata(metadata, privateKeyPem) {
    console.log('[SENDER][SIGN] metadata:', metadata);
    const privateKey = await importPrivateKey(privateKeyPem);
    const encoder = new TextEncoder();
    const data = encoder.encode(JSON.stringify(metadata));
    const signature = await window.crypto.subtle.sign(
        { name: 'RSASSA-PKCS1-v1_5' },
        privateKey,
        data
    );
    return btoa(String.fromCharCode(...new Uint8Array(signature)));
}
async function compressFile(file) {
    const arrayBuffer = await file.arrayBuffer();
    return pako.deflate(new Uint8Array(arrayBuffer));
}
function generateNonce() {
    return window.crypto.getRandomValues(new Uint8Array(12));
}
async function sha512Hash(data) {
    const hashBuffer = await window.crypto.subtle.digest('SHA-512', data);
    return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
}
function concatUint8Arrays(arrays) {
    let totalLength = arrays.reduce((sum, arr) => sum + arr.length, 0);
    let result = new Uint8Array(totalLength);
    let offset = 0;
    for (let arr of arrays) {
        result.set(arr, offset);
        offset += arr.length;
    }
    return result;
}
async function encryptCompressedFile(compressedData, sessionKey, nonce) {
    const encrypted = await window.crypto.subtle.encrypt(
        { name: 'AES-GCM', iv: nonce },
        sessionKey,
        compressedData
    );
    return new Uint8Array(encrypted);
}

// S·ª≠a h√†m g·ª≠i session key qua socket: lu√¥n g·ª≠i base64 chu·∫©n
function arrayBufferToBase64(buffer) {
    let binary = '';
    let bytes = new Uint8Array(buffer);
    for (let i = 0; i < bytes.byteLength; i++) {
        binary += String.fromCharCode(bytes[i]);
    }
    return window.btoa(binary);
}
async function sendSessionKeyWS(receiver, encryptedSessionKey) {
    const sessionKeyBase64 = arrayBufferToBase64(encryptedSessionKey);
    console.log('[DEBUG][Sender] sessionKeyBase64 g·ª≠i ƒëi:', sessionKeyBase64);
    socket.emit('send_session_key', {
        sender: currentUsername,
        receiver: receiver,
        encrypted_session_key: sessionKeyBase64
    });
}
genSessionKeyBtn.onclick = async function() {
    const receiver = getReceiverInputUsername();
    const receiverPublicKey = receiverPublicKeyInput.value.trim();
    if (!receiver) {
        sessionKeyStatus.style.display = 'block';
        showAlert(sessionKeyStatus, 'danger', 'Vui l√≤ng nh·∫≠p t√™n ng∆∞·ªùi nh·∫≠n!');
        return;
    }
    if (!receiverPublicKey) {
        sessionKeyStatus.style.display = 'block';
        showAlert(sessionKeyStatus, 'danger', 'Vui l√≤ng nh·∫≠p ho·∫∑c d√°n public key ng∆∞·ªùi nh·∫≠n tr∆∞·ªõc!');
        return;
    }
    sessionKeyStatus.style.display = 'block';
    showAlert(sessionKeyStatus, 'info', 'ƒêang sinh session key...');
    let sessionKey;
    try {
        sessionKey = await generateSessionKey();
    } catch (err) {
        showAlert(sessionKeyStatus, 'danger', 'L·ªói sinh session key!');
        return;
    }
    const sessionKeyBuffer = await exportSessionKey(sessionKey);
    let encryptedSessionKey;
    try {
        encryptedSessionKey = await encryptSessionKey(sessionKeyBuffer, receiverPublicKey);
    } catch (err) {
        showAlert(sessionKeyStatus, 'danger', 'L·ªói m√£ h√≥a session key!');
        return;
    }
    lastSessionKey = sessionKey;
    lastEncryptedSessionKey = encryptedSessionKey;
    lastReceiver = receiver;
    sendSessionKeyWS(receiver, encryptedSessionKey);
    showAlert(sessionKeyStatus, 'success', 'ƒê√£ g·ª≠i session key th√†nh c√¥ng!');
};

// --- L·ªãch s·ª≠ g·ª≠i file (backend) ---
async function saveSendHistoryBackend(entry) {
    try {
        await fetch('/api/file_history', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(entry)
        });
    } catch (err) {}
}
async function renderSendHistory() {
    const tbody = document.getElementById('history-send-tbody');
    tbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">ƒêang t·∫£i...</td></tr>';
    try {
        const res = await fetch('/api/file_history?role=sender');
        const data = await res.json();
        if (data.status === 'success' && data.history.length > 0) {
            tbody.innerHTML = '';
            for (const item of data.history) {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td>${item.filename}</td>
                    <td>${item.peer}</td>
                    <td>${item.time}</td>
                    <td><span class="badge ${item.status === 'success' ? 'bg-success' : 'bg-danger'}">${item.status === 'success' ? 'Th√†nh c√¥ng' : 'L·ªói'}</span></td>
                `;
                tbody.appendChild(tr);
            }
        } else {
            tbody.innerHTML = '<tr><td colspan="4" class="text-center text-muted">Ch∆∞a c√≥ l·ªãch s·ª≠ g·ª≠i file</td></tr>';
        }
    } catch (err) {
        tbody.innerHTML = '<tr><td colspan="4" class="text-center text-danger">L·ªói t·∫£i l·ªãch s·ª≠!</td></tr>';
    }
}
window.addEventListener('DOMContentLoaded', renderSendHistory);

// --- Th√¥ng b√°o tr·∫°ng th√°i g·ª≠i/nh·∫≠n file th·ªùi gian th·ª±c
const fileStatusDiv = document.createElement('div');
fileStatusDiv.id = 'file-status-realtime';
document.querySelector('.content').prepend(fileStatusDiv);

socket.on('file_status_notify', function(data) {
    let type = data.status === 'ACK' ? 'success' : 'danger';
    showAlert(fileStatusDiv, type, `Tr·∫°ng th√°i g·ª≠i file: <b>${data.status}</b> - ${data.message}`);
    setTimeout(() => { fileStatusDiv.innerHTML = ''; }, 6000);
});

// --- Hi·ªÉn th·ªã alert tr·∫°ng th√°i cho c√°c b∆∞·ªõc
function showAlert(target, type, message) {
    target.innerHTML = `<div class="alert alert-${type} fade-in d-flex align-items-center" role="alert">
        ${type === 'info' ? '<span class="spinner-border spinner-border-sm me-2"></span>' : ''}
        <div>${message}</div>
    </div>`;
}

// H√†m canonicalize: serialize object v·ªõi key theo alphabet
function canonicalize(obj) {
    if (Array.isArray(obj)) {
        return `[${obj.map(canonicalize).join(",")}]`;
    } else if (obj && typeof obj === "object") {
        return `{${Object.keys(obj).sort().map(
            k => JSON.stringify(k) + ":" + canonicalize(obj[k])
        ).join(",")}}`;
    } else {
        return JSON.stringify(obj);
    }
}

// --- G·ª≠i file b·∫£o m·∫≠t (n√©n, m√£ h√≥a, hash, k√Ω, g·ª≠i) ---
sendFileForm.onsubmit = async function(e) {
    e.preventDefault();
    const fileInput = document.getElementById('file');
    const privateKeyInput = document.getElementById('private_key');
    const receiverInput = document.getElementById('receiver_username');
    const expirationInput = document.getElementById('expiration');
    const resultDiv = document.getElementById('send-file-result');
    if (!fileInput.files[0] || !privateKeyInput.value.trim() || !receiverInput.value.trim()) {
        showAlert(resultDiv, 'danger', 'Vui l√≤ng nh·∫≠p ƒë·ªß th√¥ng tin!');
        return;
    }
    const file = fileInput.files[0];
    const privateKeyPem = privateKeyInput.value.trim();
    const receiver = receiverInput.value.trim();
    let expiration = null;
    if (expirationInput && expirationInput.value) {
        const mins = parseInt(expirationInput.value);
        if (!isNaN(mins) && mins > 0) {
            expiration = new Date(Date.now() + mins * 60000).toISOString();
        }
    }
    if (!lastSessionKey || !lastEncryptedSessionKey || lastReceiver !== receiver) {
        showAlert(resultDiv, 'danger', 'B·∫°n c·∫ßn t·∫°o v√† g·ª≠i session key tr∆∞·ªõc khi g·ª≠i file!');
        return;
    }
    let status = 'success';
    let errorMsg = '';
    try {
        updateStepStatusSend('sign', 'processing', 'ƒêang k√Ω s·ªë metadata...');
        let metadata = {
            filename: file.name,
            timestamp: new Date().toISOString(),
            filetype: file.type || 'text/plain',
            expiration: expiration
        };
        // Serialize metadata b·∫±ng canonicalize
        let metadataString = canonicalize(metadata);
        let signature = await signMetadata(metadataString, privateKeyPem);
        updateStepStatusSend('sign', 'done', 'ƒê√£ k√Ω s·ªë metadata!');
        updateStepStatusSend('compress', 'processing', 'ƒêang n√©n file...');
        const compressed = await compressFile(file);
        updateStepStatusSend('compress', 'done', 'ƒê√£ n√©n file!');
        updateStepStatusSend('encrypt', 'processing', 'ƒêang m√£ h√≥a file...');
        const nonce = generateNonce();
        const ciphertext = await encryptCompressedFile(compressed, lastSessionKey, nonce);
        updateStepStatusSend('encrypt', 'done', 'ƒê√£ m√£ h√≥a file!');
        updateStepStatusSend('hash', 'processing', 'ƒêang t√≠nh hash...');
        // Log debug gi√° tr·ªã tr∆∞·ªõc khi t√≠nh hash
        let hashInputArr = [nonce, ciphertext];
        if (expiration) {
            const expBytes = new TextEncoder().encode(expiration);
            hashInputArr.push(new Uint8Array(expBytes));
        }
        const hashInput = concatUint8Arrays(hashInputArr);
        const hash = await sha512Hash(hashInput);
        updateStepStatusSend('hash', 'done', 'ƒê√£ t√≠nh hash!');
        updateStepStatusSend('send', 'processing', 'ƒêang g·ª≠i file...');
        // Ki·ªÉm tra t·ª± ƒë·ªông nonce, ciphertext tr∆∞·ªõc khi g·ª≠i (assert)
        function isValidUint8Array(arr) {
            return arr && typeof arr === 'object' && typeof arr.length === 'number' && arr.length > 0 && arr instanceof Uint8Array;
        }
        if (!isValidUint8Array(nonce) || !isValidUint8Array(ciphertext)) {
            updateStepStatusSend('encrypt', 'error', 'nonce ho·∫∑c ciphertext kh√¥ng ph·∫£i Uint8Array h·ª£p l·ªá!');
            showAlert(resultDiv, 'danger', 'L·ªói: nonce ho·∫∑c ciphertext kh√¥ng ph·∫£i Uint8Array h·ª£p l·ªá, kh√¥ng th·ªÉ g·ª≠i file!');
            return;
        }
        // Log debug gi√° tr·ªã g·ª≠i ƒëi ra giao di·ªán
        const debugDiv = document.getElementById('send-file-debug-log');
        if (debugDiv) {
            debugDiv.style.display = 'block';
            debugDiv.innerHTML = `<pre style='font-size:13px;max-height:300px;overflow:auto;background:#f8f9fa;border:1px solid #ccc;padding:8px;'>` +
                JSON.stringify({
                    sender: currentUsername,
                    receiver: receiver,
                    filename: file.name,
                    nonce: Array.from(nonce),
                    ciphertext: Array.from(ciphertext),
                    hash: hash,
                    signature: signature,
                    metadataString: metadataString, // log string ƒë√£ k√Ω
                    expiration: expiration,
                    encrypted_session_key: arrayBufferToBase64(lastEncryptedSessionKey)
                }, null, 2) + '</pre>';
        }
        // G·ª≠i file qua socket, LU√îN g·ª≠i metadataString ƒë√£ canonicalize
        socket.emit('send_file_data', {
            sender: currentUsername,
            receiver: receiver,
            filename: file.name,
            nonce: Array.from(nonce),
            ciphertext: Array.from(ciphertext),
            hash: hash,
            signature: signature,
            metadataString: metadataString, // G·ª≠i string ƒë√£ k√Ω
            expiration: expiration,
            encrypted_session_key: arrayBufferToBase64(lastEncryptedSessionKey)
        });
        updateStepStatusSend('send', 'done', 'ƒê√£ g·ª≠i file th√†nh c√¥ng!');
        showAlert(resultDiv, 'success', 'ƒê√£ g·ª≠i file b·∫£o m·∫≠t th√†nh c√¥ng!');
    } catch (err) {
        status = 'error';
        errorMsg = err + '';
        updateStepStatusSend('send', 'error', 'L·ªói g·ª≠i file b·∫£o m·∫≠t!');
        showAlert(resultDiv, 'danger', 'L·ªói g·ª≠i file b·∫£o m·∫≠t: ' + err);
    }
    // L∆∞u l·ªãch s·ª≠ g·ª≠i file l√™n backend
    await saveSendHistoryBackend({
        username: currentUsername,
        role: 'sender',
        filename: file.name,
        peer: receiver,
        status: status,
        time: new Date().toLocaleString(),
        error: errorMsg
    });
    renderSendHistory();
};

function getReceiverInputUsername() {
    return (document.getElementById('receiver_username').value || '').trim().toLowerCase();
}

async function updateReceiverStatus() {
    const username = getReceiverInputUsername();
    const statusDiv = document.getElementById('receiver-status');
    if (!username) {
        statusDiv.innerHTML = '';
        return;
    }
    statusDiv.innerHTML = '<span class="spinner-border spinner-border-sm text-info"></span> ƒêang ki·ªÉm tra tr·∫°ng th√°i...';
    try {
        const res = await fetch(`/api/session_status?username=${encodeURIComponent(username)}`);
        const data = await res.json();
        if (data.status === 'success' && data.sessions.length > 0) {
            const online = data.sessions[0].online;
            if (online) {
                statusDiv.innerHTML = '<span class="badge bg-success"><i class="bi bi-circle-fill"></i> ƒêang online</span>';
            } else {
                statusDiv.innerHTML = '<span class="badge bg-secondary"><i class="bi bi-circle"></i> Offline</span>';
            }
        } else {
            statusDiv.innerHTML = '<span class="badge bg-danger">Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi nh·∫≠n</span>';
        }
    } catch (err) {
        statusDiv.innerHTML = '<span class="badge bg-danger">L·ªói ki·ªÉm tra tr·∫°ng th√°i</span>';
    }
}
document.getElementById('receiver_username').addEventListener('input', function() {
    updateReceiverStatus();
    // Enable/disable handshake button tu·ª≥ theo tr·∫°ng th√°i
    const receiver = getReceiverInputUsername();
    const handshakeBtn = document.getElementById('start-handshake');
    if (!receiver) {
        handshakeBtn.disabled = true;
    } else {
        handshakeBtn.disabled = false;
    }
});
window.addEventListener('DOMContentLoaded', function() {
    updateReceiverStatus();
    // ƒê·∫£m b·∫£o tr·∫°ng th√°i n√∫t handshake ƒë√∫ng khi load l·∫°i
    const receiver = getReceiverInputUsername();
    const handshakeBtn = document.getElementById('start-handshake');
    if (!receiver) {
        handshakeBtn.disabled = true;
    } else {
        handshakeBtn.disabled = false;
    }
});

// --- Username logic ---
function getSenderUsername() {
    // L·∫•y username t·ª´ localStorage ho·∫∑c input
    const val = (localStorage.getItem('sender_username') || document.getElementById('sender-username-input').value || '').trim().toLowerCase();
    return val;
}
function setSenderUsername(username) {
    localStorage.setItem('sender_username', username.trim().toLowerCase());
}
function showSenderLogin() {
    document.getElementById('sender-login-section').style.display = 'block';
    document.getElementById('sender-username-display').style.display = 'none';
}
function showSenderUsername(username) {
    document.getElementById('current-sender-username').textContent = username;
    document.getElementById('sender-login-section').style.display = 'none';
    document.getElementById('sender-username-display').style.display = 'block';
}
// Kh·ªüi t·∫°o username khi load trang
window.addEventListener('DOMContentLoaded', function() {
    const saved = getSenderUsername();
    if (saved) {
        showSenderUsername(saved);
        emitRegisterUsername();
        window.currentUsername = saved;
    } else {
        showSenderLogin();
    }
});
// ƒê·∫£m b·∫£o khi l∆∞u username g·ª≠i th√¨ lu√¥n c·∫≠p nh·∫≠t localStorage v√† hi·ªÉn th·ªã l·∫°i
if (document.getElementById('save-sender-username')) {
    document.getElementById('save-sender-username').onclick = async function() {
        const val = document.getElementById('sender-username-input').value.trim().toLowerCase();
        if (!val) { alert('Vui l√≤ng nh·∫≠p username!'); return; }
        setSenderUsername(val);
        showSenderUsername(val);
        window.currentUsername = val;
        emitRegisterUsername();
        console.log('[Socket] ƒê√£ g·ª≠i register_username:', val);
        // --- T·ª± ƒë·ªông sinh c·∫∑p kh√≥a RSA n·∫øu ch∆∞a c√≥ ---
        if (!localStorage.getItem('private_key') || !localStorage.getItem('public_key')) {
            try {
                const keyPair = await window.crypto.subtle.generateKey(
                    {
                        name: 'RSA-OAEP',
                        modulusLength: 2048,
                        publicExponent: new Uint8Array([1, 0, 1]),
                        hash: 'SHA-256',
                    },
                    true,
                    ['encrypt', 'decrypt']
                );
                // Export private key
                const priv = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);
                const privPem = arrayBufferToPem(priv, 'PRIVATE KEY');
                localStorage.setItem('private_key', privPem);
                // Export public key
                const pub = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);
                const pubPem = arrayBufferToPem(pub, 'PUBLIC KEY');
                localStorage.setItem('public_key', pubPem);
                // Hi·ªÉn th·ªã public key n·∫øu c√≥ textarea
                if (document.getElementById('sender_public_key_display')) {
                    document.getElementById('sender_public_key_display').value = pubPem;
                }
                alert('ƒê√£ t·ª± ƒë·ªông sinh v√† l∆∞u c·∫∑p kh√≥a RSA cho t√†i kho·∫£n n√†y!');
            } catch (e) {
                alert('L·ªói khi sinh c·∫∑p kh√≥a RSA t·ª± ƒë·ªông: ' + e);
            }
        }
    };
}

function arrayBufferToPem(buffer, label) {
    const binary = String.fromCharCode.apply(null, new Uint8Array(buffer));
    const base64 = window.btoa(binary);
    const lines = base64.match(/.{1,64}/g).join('\n');
    return `-----BEGIN ${label}-----\n${lines}\n-----END ${label}-----`;
}
// ...existing code...

document.getElementById('change-sender-username').onclick = function() {
    showSenderLogin();
    setTimeout(() => {
        document.getElementById('sender-username-input').focus();
    }, 100);
};
function emitRegisterUsername() {
    const username = getSenderUsername();
    if (username && typeof socket !== 'undefined' && socket.connected) {
        socket.emit('register_username', {username: username});
        console.log('[Socket] ƒê√£ g·ª≠i register_username:', username);
    } else {
        console.warn('[Socket] Ch∆∞a c√≥ username ho·∫∑c socket ch∆∞a k·∫øt n·ªëi!');
    }
}
socket.on('connect', function() {
    const username = getSenderUsername();
    if (username) {
        emitRegisterUsername();
        console.log('[Socket] K·∫øt n·ªëi l·∫°i, t·ª± ƒë·ªông ƒëƒÉng k√Ω username:', username);
    } else {
        console.warn('[Socket] K·∫øt n·ªëi nh∆∞ng ch∆∞a nh·∫≠p username!');
    }
});
socket.on('reconnect', function() {
    const username = getSenderUsername();
    if (username) {
        emitRegisterUsername();
        console.log('[Socket] Reconnect, t·ª± ƒë·ªông ƒëƒÉng k√Ω l·∫°i username:', username);
    } else {
        console.warn('[Socket] Reconnect nh∆∞ng ch∆∞a nh·∫≠p username!');
    }
});

// --- Handshake ---
// ƒê·∫£m b·∫£o ch·ªâ khai b√°o 1 l·∫ßn ·ªü ƒë·∫ßu file/script
if (typeof handshakeTimeout === 'undefined') {
    var handshakeTimeout = null;
}
if (typeof handshakeInProgress === 'undefined') {
    var handshakeInProgress = false;
}

handshakeBtn.onclick = function() {
    console.log('[DEBUG] handshakeBtn clicked');
    if (handshakeBtn.disabled) {
        console.warn('[DEBUG] handshakeBtn is disabled');
        return;
    }
    // L·∫•y username ƒë·ªông nh·∫•t
    const currentUsername = getSenderUsername();
    updateStepStatusSend('handshake', 'processing', 'ƒêang handshake...');
    const receiver = getReceiverInputUsername();
    if (!receiver) {
        handshakeStatus.style.display = 'block';
        showAlert(handshakeStatus, 'danger', 'Vui l√≤ng nh·∫≠p t√™n ng∆∞·ªùi nh·∫≠n!');
        return;
    }
    handshakeStatus.style.display = 'block';
    showAlert(handshakeStatus, 'info', 'ƒêang g·ª≠i b·∫Øt tay...');
    console.log('[Handshake] G·ª≠i handshake_hello t·ªõi', receiver, 't·ª´', currentUsername);
    socket.emit('handshake_hello', {
        sender: currentUsername,
        receiver: receiver,
        message: 'Hello'
    });
    handshakeInProgress = true;
    // Timeout n·∫øu kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi
    if (handshakeTimeout) clearTimeout(handshakeTimeout);
    handshakeTimeout = setTimeout(() => {
        if (handshakeInProgress) {
            handshakeStatus.style.display = 'block';
            showAlert(handshakeStatus, 'danger', 'Kh√¥ng nh·∫≠n ƒë∆∞·ª£c ph·∫£n h·ªìi handshake t·ª´ ng∆∞·ªùi nh·∫≠n. Vui l√≤ng ki·ªÉm tra l·∫°i tr·∫°ng th√°i online ho·∫∑c th·ª≠ l·∫°i!');
            updateStepStatusSend('handshake', 'error', 'Handshake th·∫•t b·∫°i!');
            handshakeInProgress = false;
        }
    }, 5000);
};
socket.on('handshake_ready', function(data) {
    console.log('[Handshake] Nh·∫≠n handshake_ready:', data);
    handshakeStatus.style.display = 'block';
    // Ph√¢n bi·ªát ph·∫£n h·ªìi handshake ch·ªß ƒë·ªông hay reply t·ª´ receiver
    let infoMsg = data && data.sender && data.receiver
        ? `Ph·∫£n h·ªìi b·∫Øt tay t·ª´ <b>${data.sender}</b> t·ªõi <b>${data.receiver}</b>: ${data.message}`
        : data.message;
    showAlert(handshakeStatus, 'success', infoMsg);
    updateStepStatusSend('handshake', 'done', 'Handshake th√†nh c√¥ng!');
    handshakeInProgress = false;
    if (handshakeTimeout) clearTimeout(handshakeTimeout);
});
document.addEventListener('DOMContentLoaded', function() {
    const fillKeyBtn = document.getElementById('fill-private-key');
    if (fillKeyBtn) {
        fillKeyBtn.addEventListener('click', function() {
            // ∆Øu ti√™n l·∫•y t·ª´ localStorage 'sender_private_key', n·∫øu kh√¥ng c√≥ th√¨ l·∫•y 'private_key'
            let privateKey = localStorage.getItem('sender_private_key') || localStorage.getItem('private_key') || '';
            if (!privateKey) {
                alert('Kh√¥ng t√¨m th·∫•y private key trong tr√¨nh duy·ªát!');
            }
            document.getElementById('private_key').value = privateKey;
        });
    }
});
document.getElementById('clear-send-history').addEventListener('click', async function() {
    if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ g·ª≠i file?')) {
        await fetch('/api/file_history?role=sender', { method: 'DELETE' });
        renderSendHistory();
    }
});
// Th√™m v√πng hi·ªÉn th·ªã k·∫øt qu·∫£ nh·∫≠n session key ·ªü ph√≠a sender
if (!document.getElementById('session-key-send-result')) {
    const div = document.createElement('div');
    div.id = 'session-key-send-result';
    div.className = 'alert alert-info mt-3';
    div.style.display = 'none';
    document.querySelector('.content').prepend(div);
}
const sessionKeySendResultDiv = document.getElementById('session-key-send-result');

// L·∫Øng nghe ph·∫£n h·ªìi x√°c nh·∫≠n nh·∫≠n session key t·ª´ ph√≠a receiver
socket.on('session_key_ack', function(data) {
    // data: { sender, receiver, status, message }
    console.log('[SENDER][ACK session key]', data);
    if (sessionKeySendResultDiv) {
        sessionKeySendResultDiv.style.display = 'block';
        let type = data.status === 'success' ? 'alert-success' : 'alert-danger';
        sessionKeySendResultDiv.className = 'alert mt-3 ' + type;
        sessionKeySendResultDiv.innerHTML = `<b>Ph·∫£n h·ªìi nh·∫≠n session key t·ª´ <span class='text-primary'>${data.receiver}</span>:</b><br>${data.message}`;
    }
});

function showPrivateKey() {
    // ∆Øu ti√™n l·∫•y t·ª´ localStorage 'sender_private_key', n·∫øu kh√¥ng c√≥ th√¨ l·∫•y 'private_key'
    let privateKey = localStorage.getItem('sender_private_key') || localStorage.getItem('private_key') || '';
    document.getElementById('show_private_key').value = privateKey;
    if (!privateKey) {
        alert('Kh√¥ng t√¨m th·∫•y private key trong tr√¨nh duy·ªát!');
    }
}

// Th√™m script l·∫•y public key ng∆∞·ªùi nh·∫≠n
document.getElementById('fetch-receiver-public-key').onclick = async function() {
    const receiver = getReceiverInputUsername();
    const textarea = document.getElementById('receiver_public_key');
    if (!receiver) {
        textarea.value = '';
        alert('Vui l√≤ng nh·∫≠p username ng∆∞·ªùi nh·∫≠n tr∆∞·ªõc!');
        return;
    }
    textarea.value = 'ƒêang l·∫•y public key...';
    try {
        const res = await fetch(`/api/public_key/${encodeURIComponent(receiver)}`);
        const data = await res.json();
        if (data.status === 'success') {
            textarea.value = data.public_key;
            genSessionKeyBtn.disabled = false;
        } else {
            textarea.value = '';
            genSessionKeyBtn.disabled = true;
            alert('Kh√¥ng t√¨m th·∫•y public key ng∆∞·ªùi nh·∫≠n!');
        }
    } catch (err) {
        textarea.value = '';
        genSessionKeyBtn.disabled = true;
        alert('L·ªói l·∫•y public key ng∆∞·ªùi nh·∫≠n!');
    }
};
// B·∫≠t/t·∫Øt n√∫t t·∫°o session key d·ª±a v√†o public key ng∆∞·ªùi nh·∫≠n
const receiverPublicKeyInput = document.getElementById('receiver_public_key');
receiverPublicKeyInput.addEventListener('input', function() {
    if (receiverPublicKeyInput.value.trim().length > 0) {
        genSessionKeyBtn.disabled = false;
    } else {
        genSessionKeyBtn.disabled = true;
    }
});
window.addEventListener('DOMContentLoaded', function() {
    // B·∫≠t n√∫t t·∫°o session key n·∫øu ƒë√£ c√≥ public key khi load l·∫°i trang
    if (receiverPublicKeyInput.value.trim().length > 0) {
        genSessionKeyBtn.disabled = false;
    } else {
        genSessionKeyBtn.disabled = true;
    }
});
</script>
{% endblock content %}